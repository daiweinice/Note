## Java内存分配详解

### 1. 基本概念

#### (1) JVM内存简述

每运行一个Java程序会产生一个Java进程，每个Java进程可能包含一个或者多个线程，每一个Java进程对应唯一一个JVM实例，每一个JVM实例唯一对应一个堆，每一个线程有一个自己私有的栈。

进程所创建的所有类的实例（也就是对象）或数组（指的是数组的本身，不是引用）都放在堆中, **并由该进程所有的线程共享。**

Java中分配堆内存是自动初始化的，即为一个对象分配内存的时候，会初始化这个对象中的变量。虽然Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在栈中分配的, 也**就是说在建立一个对象时在堆和栈中都分配内存，在堆中分配的内存实际存放这个被创建的对象的本身，而在栈中分配的内存只是存放指向这个堆对象的引用而已。**

局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。

**JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method，也叫静态区)**

#### (2) 堆区

+ 存储的全部是对象，每个对象都包含一个与之对应的class的信息(class的目的是得到操作指令) 
+ JVM只有一个堆区(heap)，且被所有线程共享，**堆中不存放基本类型和对象引用，只存放对象本身和数组本身**

#### (3) 栈区

+ 每个线程包含一个栈区，**栈中只保存基础数据类型本身和自定义对象的引用**
+ 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问
+ 栈又分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)

#### (4) 方法区(静态区)

+ 方法区被所有的线程共享，**方法区包含所有的class（class是指类的原始代码，要创建一个类的对象，首先要把该类的代码加载到方法区中，并且初始化）和static变量**。
+ 方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。



### 2. 案例分析

```java
public class Test{
    public static main(String[] args){
        Student student_1 = new Student("小明", 20);
        Student student_2 = new Student("小红", 19);

        student_1.getName();
    }
}

public class Student{
    String name;
    int age;

    public Student(String name, int age){
        this.name = name;
        this.age = age;
    }

    public getName(){
        System.out.println(this.name);
    }
}
```

+ 运行该程序时，首先启动一个Java虚拟机进程，这个进程首先从classpath中找到Test.class文件，读取这个文件中的二进制数据，然后把Test类的类信息存放到方法区中，这就是Test类的加载过程。
+ 接着, Java虚拟机定位到方法区中Main()方法的字节码，开始执行它的指令。
+ 指令执行过程如下: 
    + Java虚拟机到方法区找到Student类的信息，没有找到，因为Student类还没有加载到方法区（这里可以看出，**Java中的内部类是单独存在的，而且刚开始的时候不会跟随包含类一起被加载，等到要用的时候才被加载**）。Java虚拟机立马加载Student类，把Student类的类型信息存放在方法区里。
    + Java虚拟机首先在堆区中为一个新的Student实例分配内存, 并在方法区中存放该对象的引用。
    + JVM的进程中，每个线程都会拥有一个**方法调用栈**，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为**栈帧**，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的栈帧用来存储方法的参数、局部变量和运算过程中的临时数据。
    + 位于“=”前的student_1是一个在main()方法中定义的一个变量(一个Sample对象的引用)，因此，它被会添加到了执行main()方法的主线程的方法调用栈中。而“=”将把这个`student_1`变量指向堆区中的Student实例。
    + JVM在堆区里继续创建另一个Student实例，并在main方法的方法调用栈中添加一个`student_2`变量，该变量指向堆区中刚才创建的Student新实例。
    + JVM执行`student_1`的`getName()`方法。当JAVA虚拟机执行该方法时，JAVA虚拟机根据局部变量student_1持有的引用，定位到堆区中的Student实例，再根据Student实例持有的引用，定位到方法区中Student类的类型信息，从而获得getName()方法的字节码，接着执行getName()方法包含的指令。

![image-20200414205430798](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/image-20200414205430798.png)

### 3. 辨析

#### (1) 在Java语言里堆(heap)和栈(stack)里的区别?

栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。

与C++不同，**Java自动管理栈和堆**，程序员不能直接地设置栈或堆。   

栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，数据可以共享(详见下面的介绍)。

堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

#### (2) Java中的2种数据类型

**基本数据类型:**

基本类型(primitive types), 共有8类，即int, short, long, byte, float, double, boolean, char(**注意String并不是基本类型**)。

这种类型的定义是通过诸如`int a = 3; long b = 255L;`的形式来定义的，称为自动变量。**自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。**如`int a = 3` 这里的a是一个指向int类型的引用，指向3这个字面值。**这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。** 

栈有一个很重要的特性: 存在栈中的数据可以共享。假设我们同时定义:  `int a = 3; int b = 3;`  编译器先处理`int a = 3`首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，如果没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理`int b = 3`, 在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 　

这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令`a=4`那么，b不会等于4，还是等于3。

在编译器内部，遇到`a=4`时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值, 如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 　

**包装类:**

另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。**这些类数据全部存在于堆中**，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 

