# JVM

## 一、 JVM 体系结构

![image-20200710084256851](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/image-20200710084256851.png)

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/JVM体系结构.png)

**栈:** 栈是线程私有的, 线程结束, 栈内存释放。栈主管程序运行、生命周期和线程同步。栈中存放**局部变量、对象引用、实例方法。**栈不存在垃圾回收问题。递归调用容易发生栈溢出 StackOverflowError。栈的每一个元素称为**栈帧**, 每一个栈帧内部又由**局部变量表、操作数栈、动态链接、返回地址**构成。

注意: 对于一个实例对象中的成员方法而言，如果方法中包含局部变量是基本数据类型，将直接存储在工作内存的帧栈结构中，但倘若局部变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型还是引用类型，都会被存储到堆区。

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/栈的内部结构.png)

**本地方法栈:** 与栈类似, 只不过本地方法栈用于登记要执行的 native 方法。

**程序计数器:** 每一个线程都有一个程序计数器, 是线程私有的。程序计数器记录线程将要执行的字节码指令。此区域是 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域。

**堆:** 线程共享, 主要存放**对象实例和数组**。堆内部会划分出多个线程私有的分配缓冲区, 它们在物理上不连续, 但是在逻辑上连续。

**方法区:** 方法区被所有线程共享。**类信息(构造方法、接口定义等)、静态变量、常量**存在于方法区中。常量池是方法区的一部分。方法区实际实际上在堆中, 只不过 JVM 规范单独将其抽离出来描述。所以说静态变量、常量、类信息存放于堆中也是没有问题的。JDK7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类在 Java 语言一端的映射 Class 对象存放在一起，存储于 Java 堆之中

需要注意的是, 上面提到的各种分区都是 JVM 的**规范**, 而不是具体实现。

## 二、类加载器 ClassLoader

类加载器的作用就是加载class文件。

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/类加载器.png)

类加载器不只有一个, 有**虚拟机自带加载器、启动类(根)加载器、扩展类加载器(ExtClassLoader)、应用程序加载器(AppClassLoader)**。这些加载器的使用顺序遵循**双亲委派机制**, 及优先使用父类加载器, 如果父类加载器中没有对应的类, 再使用子类加载器。

根加载器位于 rt.jar, 扩展加载器位于 jre/lib/ext 的 jar 包中。如 rt.jar 包中就有 java.lang.String, 如果我们在自己创建一个 java.lang 包并创建一个 String 类并编写 main 方法, 那么运行该 main 方法时会报错, 因为根加载器中有对应的类, 则会加载该类, 然而该类并没有 main 方法, 所以会报错。可见双亲委派机制确保了代码的安全性, 避免了随意替换 Java 自带类的情况。

一般的 class 对象通过`getClassloader()`获取到的是应用程序加载器 (AppClassLoader), 加载器也可以通过`getParent()`获取其父类加载器。如果获取值为null,  不代表没有父类加载器而是 Java无法获取, 因为 **JVM 是用 C++ 编写的**。Java 中的一些 **native** 修饰的方法交给 JVM 执行引擎执行时就是调用的 C++ 的方法, 如 Thread 的 start() 方法。

除了双亲委派机制, Java 还有**沙箱安全机制**。沙箱就是一个限制程序运行的环境, 将 Java 代码限定在虚拟机特定的运行范围中, 主要用于限制 Java 代码对系统资源如 CPU、内存、文件系统等的访问。随着 JDK 的版本更新, 沙箱安全机制也在不断更新。

## 三、native

Java 有时候需要调用底层的、其作用范围达不到的方法, 此时就需要使用 native 关键字修饰方法。JVM 中有一个本地方法栈就是用来登记这些 native 方法。最终这些方法的执行是通过本地方法接口(JNI) 调用本地方法库中的方法完成。本地方法库的方法一般是C、C++程序(Java诞生时C和C++是最火的语言)。

JNI 的作用就是扩展 Java 的使用, 融合其他的编程语言。但是现在开发一般都不会去自己调用 native 方法, 除非需要调用系统资源。如果有需要使用到其他编程语言的场景, 一般使用 HTTP 等网络连接的方式实现。

## 四、堆

一个 JVM 只有一个堆。堆需要解决垃圾回收问题, 堆满时会出现 **OOM** 错误, 即 OutOfMemoryError。不同的 JVM 堆的设计不同, 垃圾回收算法也不同, HotSpot 的堆内存主要分为三个区域, 分别是**新生区、养老区、永久区**。

![堆的内存区域划分](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/堆的内存区域划分.png)

永久区是常驻内存的, 用来存放 JDK 自身携带的 Class 对象、Interface 元数据。如果一个启动类加载了大量第三方 jar 包、Tomcat 部署了太多应用可能也会出现 OOM。永久区无垃圾回收。

永久区在不同版本的 JDK 命名也不同。
在 JDK1.6 之前被称为永久代, 常量池存在于方法区。
在 JDK1.7  也被称为永久代, 但是开始去永久代化, 常量池在堆中。
在 JDK1.8 之后, 永久代被元空间取代, 常量池在元空间中。

在运行项目时, 可以设置堆的 max 和 min 大小, 通过参数`-Xms1024m -Xmx1024m -XX:+PrintGCDetails`设置。这种 JVM 调参操作就是 **JVM 性能调优**。

可以使用 JProfiler 工具分析 OOM 原因。它的主要功能有快速定位内存泄漏、获取堆中的数据、获取大对象等。首先通过参数`-Xms1024m -Xmx1024m -XX:+HeapDumpOnOutOfMemoryError`在发生 OOM 时 Dump 出文件, 然后用 JProfiler 分析文件。

**关于方法区和永久代的辨析:**

方法区是 JVM 规范中运行时数据区的一部分, 而不是具体实现。而永久代/元空间是方法区的实现。

## 五、GC

### 引用计数法

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/引用计数法.png)

缺陷: 交叉引用

### 复制算法

伊甸区满时会进行一次 Minor GC (轻 GC)。每次 GC 伊甸区都会被清空, 幸存的对象会进入幸存区。幸存区有两个, from 区和 to 区, 其中 to 区永远是空的那个区。复制算法的作用就是**每次 GC 后将存活对象全部复制到空的区, 并严格按照内存地址排序, 同时将更新幸存对象的引用地址指向更新后的内存地址**。由于每次复制都是复制到空的区, 所以两个区的状态是动态交换的, 即第一次复制到一区, 则二区变为空, 第二次就复制到二区, 此时一区变为空, 下一次就又复制到一区...

当一个对象经历了15次 GC 还没被回收时, 它会进入老年区。可以通过参数`-xx:MaxTenuringThreshold=?`来设置进入老年区的条件。

**为什么要设置幸存区:**

设置幸存区的目的是让那些中等寿命的对象尽量在 minor GC 时被干掉，避免老年区很快被填满而触发 Full gc (重 GC), 影响系统性能。

**为什么要设置两个幸存区:**

假设只有一个幸存区, 当伊甸区填满后，Minor GC 进行垃圾回收，幸存的对象会移动到幸存区，这样循环往复。此时，幸存区被装满了，也会进行 Minor GC，将一些对象 kill 掉，幸存的对象只能保存在原来的位置，这样就会出现大量的内存碎片(被占用内存不连续)。此时当有一个比较大的对象来到幸存区时, 由于内存空间断断续续, 会影响到大对象的存储。

所以, 两个幸存区可以减少内存空间的碎片化程度。

### 标记清除法

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/标记清除算法.png)

优点:

+ 不需要额外的空间(复制算法有两个幸存区, 有空间的浪费)

缺点:

+ 两次扫描, 浪费时间
+ 产生内存碎片

### 标记压缩

在标记清除法的基础上再次扫描, 将存活对象整理在一起

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/标记压缩算法.png)

再优化: 先多次清除再进行一次压缩

### 算法对比

+ 时间复杂度: 复制算法 > 标记清除法 > 标记压缩法
+ 内存占用: 标记压缩法 = 标记清除算法 > 复制算法
+ 内存整齐度: 复制算法 = 标记压缩法 > 标记清除法

Tips:

从时间复杂度看, 复制算法是优于标记压缩算法的, 因为复制算法遇到一个幸存对象就可以直接复制到空的区(在空的区分配空间然后修改对象指针指向即可), 而标记压缩算法由于只有一片内存, 需要先进行一次标记清除后才能整理(需要大量对象的移动和交换)。

### 分代收集算法

GC使用的是分代收集算法。

+ 年轻代存活率低用复制算法 (年轻代存活率低、回收频繁, 用标记算法会导致大量内存移动, 浪费更多时间)
+ 老年代标记清除算法(内存碎片不多的情况下) + 标记压缩算法混合使用 (老年代存活率高、回收频率更低, 用复制算法会消耗更多空间)

## 六、JMM (Java 内存模型)

Java Memory Model, 是一种缓存一致性协议, 用于定义数据读写的规则。JMM 定义了线程工作内存和主内存之间的抽象关系。同时 JMM 也有一些问题, 如数据可见性问题, 可以使用 volatile 解决。

## X、问题

+ 堆中的线程私有缓存区域 TLAB（Thread Local Allocation Buffer）

    https://www.cnblogs.com/ding-dang/p/13083223.html

    https://blog.csdn.net/QGhurt/article/details/107289843