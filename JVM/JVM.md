# JVM

## 一、 JVM体系结构

![image-20200710084256851](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/image-20200710084256851.png)

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/JVM体系结构.png)

**程序计数器:** 每一个线程都有一个程序计数器, 是线程私有的, 就是一个指针, 指向要执行的指令代码。

**方法区:** 方法区被所有线程共享。**静态变量、常量、类信息(构造方法、接口定义等)、常量池存在于方法区中, 但是对象实例存在于堆内存中。**

**栈:** 栈主管程序运行、生命周期和线程同步, 线程结束, 栈内存释放。**栈中存放八大基本类型、对象引用、实例方法。**栈不存在垃圾回收问题。递归调用容易发生栈溢出 StackOverflowError。

## 二、类加载器

类加载器的作用就是加载class文件。

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/类加载器.png)

类加载器不只有一个, 有**虚拟机自带加载器、启动类(根)加载器、扩展类加载器(ExtClassLoader)、应用程序加载器(AppClassLoader)**。这些加载器的使用顺序遵循**双亲委派机制**, 及优先使用父类加载器, 如果父类加载器中没有对应的类, 则使用子类加载器。

根加载器位于 **rt.jar**, 扩展加载器位于 **jre/lib/ext** 的 jar 包中。如 rt.jar 包中就有 java.lang.String, 如果我们在自己创建一个 java.lang 包并创建一个 String 类并编写 main 方法, 那么运行该 main 方法时会报错, 因为根加载器中有对应的类, 则会加载该类, 然而该类并没有 main 方法, 所以会报错。可见双亲委派机制确保了代码的安全性, 避免了随意替换 Java 自带类的情况。

一般的class对象通过`getClassloader()`获取到的是应用程序加载器(AppClassLoader), 加载器也可以通过`getParent()`获取其父类加载器。如果获取值为null,  不是没有父类加载器而是Java无法获取, 因为**JVM是用C++编写的**。Java 中的一些 **native** 修饰的方法交给 JVM 执行引擎执行时就是调用的 C++ 的方法, 如 Thread 的 start 方法。

除了双亲委派机制, Java 还有**沙箱安全机制**。沙箱就是一个限制程序运行的环境, 将 Java 代码限定在虚拟机特定的运行范围中, 主要用于限制 Java 代码对系统资源如 CPU、内存、文件系统等的访问。随着 JDK 的版本更新, 沙箱安全机制也在不断更新。



## native

Java 有时候需要调用底层的、其作用范围达不到的方法, 此时就需要使用 native 关键字修饰方法。JVM 中有一个本地方法栈就是用来登记这些 native 方法。最终这些方法的执行是通过本地方法接口(JNI) 调用本地方法库中的方法完成。本地方法库的方法一般是C、C++程序(Java诞生时C和C++是最火的语言)。

JNI 的作用就是扩展 Java 的使用, 融合其他的编程语言。但是现在开发一般都不会去自己调用 native 方法, 除非需要调用系统资源。如果有需要使用到其他编程语言的场景, 一般使用 HTTP 等网络连接的方式实现。



## 堆

一个 JVM 只有一个堆。~~堆中主要存放类、方法、变量、常量、引用类型的实例对象。~~堆需要解决垃圾回收问题, 堆满时会出现 OOM 错误, 即 OutOfMemoryError。不同的 JVM 堆的设计不同, 垃圾回收算法也不同, HotSpot的堆内存主要分为三个区域, 分别是**新生区、养老区、永久区**。

![堆的内存区域划分](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/堆的内存区域划分.png)

永久区是常驻内存的, 用来存放 JDK 自身携带的 Class 对象、Interface元数据。如果一个启动类加载了大量第三方 jar 包、Tomcat 部署了太多应用可能也会出现 OOM。永久区无垃圾回收。

永久区在不同版本的 JDK 命名也不同。
在 JDK1.6 之前被称为永久代, 常量池存在于方法区。
在 JDK1.7  也被称为永久代, 但是开始去永久代, 常量池在堆中。
在 JDK1.8 之后, 被称为元空间, 常量池在元空间中。

在运行项目时, 可以设置堆的 max 和 min 大小。通过参数`-Xms1024m -Xmx1024m -XX:+PrintGCDetails`。可以发现, 堆的大小其实就是新生区和养老区的大小之和, ~~永久区只是逻辑上存在而物理上不存在。~~这种 JVM 调参操作就是 JVM 性能调优。

可以使用 JProfiler 工具分析 OOM 原因。它的主要功能有快速定位内存泄漏、获取堆中的数据、获取大对象等。首先通过参数`-Xms1024m -Xmx1024m -XX:+HeapDumpOnOutOfMemoryError`在发生 OOM 时 Dump 出文件, 然后用 JProfiler 分析文件。

## GC

**引用计数法:**

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/引用计数法.png)

**复制算法:**

每次 GC 新生区都会被清空, 幸存的对象会进入幸存区。幸存区有两个, from 区和 to 区, 其中 to 区永远是空的那个区。复制算法的作用就是保证当 from 区和 to 区都有对象时, 将 to 区的对象复制到 from 区, 然后将 to 区清空。

当一个对象经历了15次 GC 还没被回收时, 它会进入老年区。可以通过参数`-xx:MaxTenuringThreshold=?`来设置进入老年区的条件。

**标记清除法:**

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/标记清除算法.png)

优点:

+ 不需要额外的空间(复制算法有两个幸存区, 有空间的浪费)

缺点:

+ 两次扫描, 浪费时间
+ 产生内存碎片



**标记压缩:**

在标记清除法的基础上再次扫描, 将存活对象整理在一起

![](https://blog-1258617239.cos.ap-chengdu.myqcloud.com/blog_images/标记压缩算法.png)

再优化: 先多次清除再进行一次压缩

**总结:**

+ 时间复杂度: 复制算法 > 标记清除法 > 标记压缩法
+ 内存利用率: 标记压缩法 = 标记清除算法 > 复制算法
+ 内存整齐度: 复制算法 = 标记压缩法 > 标记清除法



**分代收集算法:**

GC使用的是分代收集算法。

+ 年轻代存活率低用复制算法
+ 老年代标记清除算法(内存碎片不多的情况下) + 标记压缩算法混合使用



## JMM

Java Memory Model, 是一种缓存一致性协议, 用于定义数据读写的规则。JMM 定义了线程工作内存和主内存之间的抽象关系。同时 JMM 也有一些问题, 如数据可见性问题, 可以使用 volatile 解决。